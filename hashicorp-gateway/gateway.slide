Intro to the gRPC-Gateway

: I'm Johan, I joined HashiCorp in March to work on Boundary. I'm excited to be here today to talk a little bit about an open source project that's dear to me. But to do that, we're going to tell a story.
: Next up: Overview



* Overview

* A new API service

- HashiPet API
- Floyd lead engineer
- Floyd uses the HashiCorp stack

* What is the gRPC-Gateway?

- Translates HTTP/JSON to gRPC and back
- Used by many HashiCorp products (Boundary, Vault, Waypoint)
- Easy to design APIs
- Floyd likes typed APIs

* Designing the API

- Floyd wants to create a RESTful HTTP/JSON

* CRUD operations

- Create a pet
- Read a pet
- List pets
- Delete a pet

* Little known features of the gateway

* PATCH requests

- Update profile pic

* Custom error handling

- Only Floyd can be the king

* HttpBody

- Serving Pictures

* Hiding internal fields

- So that no one but Floyd can be the king

* Others

- Mutating responses
- Go Templates documentation
- Field behavior
- Server side streaming
- Health checks

* Wrapping up

- Floyd has created an API
- We've learned about the gRPC-Gateway
- We've learned about some lesser known features





























* Today we will

- Introduce the gRPC-Gateway
- Design a HTTP/JSON API
- Explore some lesser known features

.image witch.svg _ 400
.caption Gopher by [[https://twitter.com/egonelbre][@egonelbre]].

:
: Next up:

* What's the gRPC-Gateway?

- HTTP/JSON <-> gRPC proxy
- Annotations in Protobuf
- Used by Consul, Vault, Boundary, Waypoint

.image rest.png _ 600
.caption Source: [[https://restful.io/rest-api-back-to-basics-c64f282d972][restful.io]]

: We mean a RESTful interface, making use of the HTTP verbs (GET, POST, PUT, PATCH, DELETE) and using JSON as the payload content type. This is the de facto standard for most public APIs today. Sometimes it's not entirely RESTful, but it's almost always using JSON. It's easy for humans to read and write, it's got native javascript support, all is well, right?
: Next up: Is everything well?

* Problems with JSON

- Not that easy to write (no trailing commas, no comments)
- Inefficient on the wire (compression helps)
- Expensive marshalling
- Poorly typed
- No single source of truth for API (OpenAPI?)

.image malformed.jpg _ 400

: As anyone who has ever had to quickly push a configuration fix to your JSON configured service knows, trailing commas are forbidden in JSON. I wish I was joking in saying that this is a big problem, but entirely new formats have been developed to deal with this problem. There's also no support for comments. It's unnecessarily verbose on the wire, but compression can help mitigate this. In large deployments, the marshalling and unmarshalling of JSON is a constant strain on response latency. Most importantly, it is not well typed enough, and there is no single way to define the interface types. OpenAPI is an option, but it's not globally adopted. Most of these problems stem from the fact that JSON was designed to be human-readable, but also effective for a machine to use. These two properties are, unfortunately, not compatible.
: Next up: Fortunately, there's a better option

* Protocol buffers

- Efficient on the wire
- Cheap marshalling
- Well typed
- A single source of truth
- Generators for different languages

.code bare.proto

: Protocol buffers have recently become more and more popular for use with internal APIs, and for good reason. They provide an efficient wire encoding, cheap marshalling, good type support and a single source of truth for your API description. Generators use the protobuf definitions to produce language specific code. Projects such as Twirp are basically the traditional HTTP/JSON application with the JSON part replaced with protobuf. This snippet is an example of what a very simple protofile might look like. We define the type User and a single field, id, of type string.
: Next up: We're going to be using it with gRPC

* gRPC

- Fast
- Type-safe
- Polyglot
- Streaming

.code service.proto

: gRPC is an RPC framework developed to make RPC as fast and safe as possible. It uses HTTP/2 by default to efficiently and quickly send data between client and server, removing most of the overhead of HTTP/1.1. It uses protobuf as the default transport encoding, piggy backing on it for type safety and speedy marshalling. It _is_ possible to use JSON with gRPC if you really want to, but it's kind of pointless. It maps the service definitions in a protofile to API services in the generated files. As we can see, we've added some extra messages for inputs, and we've defined a new service with two methods. Given this, we can generate everything we need to allow the use of gRPC between a client and server. Note that ListUsers streams the results of the operation to the client, something which is not trivial to accomplish with HTTP/JSON.
: Next up: But if you were already able to use gRPC, you wouldn't be going to this talk.
: 04:00

* The problem with novel tech

- Existing services/clients
- Company unwillingness to invest in new tech
- Public API expectation is HTTP/JSON

.image scientist.svg 350 _
.caption Gopher by [[https://twitter.com/egonelbre][@egonelbre]].

: Unfortunately, it's not always so easy to switch entire application stacks to a new framework. Often there are a number of reasons why we keep using old standards when new, better alternatives are available, such as compatibiliy with existing systems, management pressure, and in this case, the still prevalent expectation that a public API should be using HTTP/JSON.
: Next up: What can we do when we want to use gRPC but are forced to use HTTP/JSON?

* The gRPC-Gateway

- Translates HTTP/JSON requests to gRPC and back
- Simple annotation in proto files
- Provides Swagger/OpenAPI generator
- Widely used within gRPC community

.code gateway.proto

: The gRPC-gateway project allows you to design gRPC and HTTP/JSON services at the same time. It uses a cutom protobuf generator that generates a simple reverse proxy that translates on the fly from JSON to protobuf and back again. It allows you to define a URL path and HTTP verb to gRPC service method mapping with a simple annotation scheme in the protofiles. It also provides a Swagger/OpenAPI generator, in case you have some generator you want to use that requires the OpenAPI format. It has been widely adopted within the gRPC community wherever a HTTP/JSON interface is required. I've added the HTTP/JSON annotations to the previously defined service methods above. As you can see, the HTTP verb and URL path mappings are defined within the RPC definitions.
: Next up: How does it work?

* Under the hood

.image gateway.png _ 1000
.caption Source: [[https://github.com/grpc-ecosystem/grpc-gateway][gRPC-Gateway]]

: This image shows the basic building blocks of the gateway. You generate a gRPC service as usual with protoc-gen-go or your generator of choice, then you use our custom generator, protoc-gen-grpc-gateway, to generate a gateway handler file which registers the mapped HTTP verbs and URL paths to a central mux, which is then used to serve the external HTTP/JSON interface. It is common to serve the gateway and gRPC server on different ports of the same server, to allow both HTTP/JSON clients and gRPC clients, but this is not mandatory. The gateway can also be used with non-Go gRPC services, you simply connect to an external gRPC service in the setup. You can even serve the gateway and grpc-server on the same port and split traffic using HTTP headers if you want to get fancy!
: Next up: Lets take a look at an example

* Demo
[[https://github.com/johanbrandhorst/grpc-gateway-boilerplate]]

: I'm going to show you an example of the grpc-gateway from my boilerplate repo. If you have a laptop at hand please feel free to clone the repo and follow along.
: Adding a new field
: Adding a new method
: Next up: Lets explore some of the specific features of the gateway, starting with the well known types.

* Rich type support

- Protobuf includes _Well_ _Known_ _Types_ (WKT)
- Namespaced by `google.protobuf`
- Timestamp, Duration, Primitive Wrappers and more
- Special cases built into the gRPC-Gateway

.code types.proto

: These types are part of what you might call a protobuf standard library, and are always included with the proto-c compiler, meaning you don't have to manually manage their downloading and generation. They use a special namespace, google.protobuf, which make them easy to recognize. These types are predefined messages, and include messages for handling Timestamps, Durations, wrappers of primitive types, and others. All of these types have special cases built into them for the gateway, so whenever, for example, you need a Timestamp, make use of the well known type. As you can see, I've added some examples here, the timestamp type marshals to and from an RFC3339 timestamp string, the Uint32Value can be used to have nullable uint32s, and the struct type can be used to store arbitrary JSON structures. Please use the last one carefully, as the protobuf representation is a mess to work with, and should only be a last resort.
: Next up: Lets take a look at what this looks like in action.

* Rich type support example

: Next up: Another WKT has a special use in the gateway
: 20:00

* PATCH requests

- Protobuf primitive fields are non-nullable
- Best practice to use `google.protobuf.FieldMasks` for partial updates
- gRPC-Gateway Maps JSON fields to FieldMask and resource
- Contributed by Roman Azami and Daniel McDonald

.code patch.proto

: Most protobuf primitive fields such as strings and integers are non-nullable, so in order to do partial updates the best practice is the use of a special message type called a FieldMask. Exposing this implementation detail to your users however is pretty nasty, so the gRPC-Gateway supports translating JSON fields to a field mask and resource type. Fields that are are found in the input JSON are used to populate the resource and field mask, automatically. This code shows an example structure, with the service omitted. The "Output Only" comment indicates that the field is not mutable via partial updates, which is in line with the Google API design docs recommendations. This support was entirely the result of an open source contribution from Roman Azami and Daniel McDonald.
: Next up: Lets take a look at an example.

* PATCH requests example

: Next up: How do we handle errors in our service?

* Error handling

- gRPC uses the `google.rpc.Status` type
- Well defined mapping from `google.rpc.Code` codes

    INVALID_ARGUMENT    => 400
    UNATHENTICATED      => 401
    PERMISSION_DENIED   => 403
    NOT_FOUND           => 404

- Custom error handlers

.code errors.go

    gwmux := runtime.NewServeMux(
        runtime.WithErrorHandler(server.CustomErr),
    )

: When working with gRPC, we use the Status type for errors, which includes a message and a code. The gRPC-Gateway automatically translates the codes into appropriate HTTP Status codes, according to the google.rpc.Code definitions. Here we can see a sample of the error codes and their mapping. If you have more specific needs for your error handling, such as a custom error struct format, you can create your own error handling function and configure the runtime mux with it on startup. Here we have an example of an error handler that sets the response code to one that is mapped from the grpc status, and the response body to simply be the error message. Note that using custom errors like this will break the default OpenAPI generator definitions.
: Next up: Lets see what that looks like.

* Error handling example

: Next up: Wrapping up

* Conclusion

- We've created a HTTP/JSON service
- We've snuck in a gRPC service into our stack
- New clients can use gRPC
- Old clients don't have to change
- Only a snapshot of all the features of the gRPC-Gateway

.image standing.svg _ 300
.caption Gopher by [[https://twitter.com/egonelbre][@egonelbre]].

: We've created a HTTP/JSON service, but used gRPC and protobuf under the hood. This allows us to get all the benefits of the protobuf IDL while still exposing a JSON interface externally. We've also managed to sneak a gRPC service into our stack, and now it's much easier to argue that gRPC might be something worth trying. New clients can use gRPC, and old clients can keep using the JSON interface. Most importantly, we've found an easy, robust way to write RESTful services, and we've only explored a snapshot of all that the gRPC-gateway has to offer. Other features include the ability to set cookies, perform header-based authentication in interceptors and much more! I hope you will, as I do, use the gRPC gateway for your next HTTP/JSON service.
